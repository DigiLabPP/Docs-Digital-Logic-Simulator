[
    {
        "name": "2x1 MUX",
        "desc": "This block selects one from the two Data inputs based on the logic level at the Select line/Select input and passes to the output, while the other Data input which isn't selected, doesn't influence the output.",
        "truth_table": "",
        "code": "2x1_MUX D1 A D0 B S C Y D \n# (D1 and D0 - Data inputs), S-Select input, \n# Y-Output, Order of the Subciruit labels doesn't matter",
        "syntax": "2x1_MUX {[Subcircuit-label-n] [label-n]}\n# where, the Subcircuit labels are D1, D0, S and Y\n# All Subcircuit labels are mandatory\n# Order is arbitrary"
    },
    {
        "name": "4x1 MUX",
        "desc": "This block selects one from the four Data inputs, binary encoded from zero to three, based on the logic levels at the Select lines/Select inputs and passes to the output, while the other Data inputs which aren't selected, don't influence the output for that selection.",
        "truth_table": "",
        "code": "4x1_MUX D3 A D2 B D1 C D0 D S1 E S0 F Y G \n# Order of the Subciruit labels doesn't matter",
        "syntax": "4x1_MUX {[Subcircuit-label-n] [label-n]}\n# where, the Subcircuit labels are D3, D2, D1, D0, S and Y\n# All Subcircuit labels are mandatory\n# Order is arbitrary"
    },
    {
        "name": "4 BIT RC Adder",
        "desc": "4-Bit Ripple Carry Adder. Consists of 4 sections of Full Adders connected in a carry-ripple fashion. Receives Addend and Augend bits with Input carry.",
        "truth_table": "",
        "code": "4BIT_RC_ADDER A3 a3 B3 b3 A2 a2 B2 b2 A1 a1 \nB1 b1 A0 a0 B0 b0 S3 s3 S2 s2 S1 s1 \nS0 s0 C_IN c1 C_OUT c2 \n# (A0-A3): Augend bits, (B0-B3): Addend bits, (S0-S3): Sum bits, \n# C_IN: Input Carry, C_OUT: Output Carry",
        "syntax": "4BIT_RC_ADDER {[Subcircuit-label-n] [label-n]}\n# Where, the Subcircuit labels are \n# A3-A0, B3-B0, S3-S0, C_IN, C_OUT"
    },
    {
        "name": "Full Adder",
        "desc": "Performs binary addition of an Augend bit with an Addend bit with an Input Carry and outputs Sum bit and Output carry.",
        "truth_table": "",
        "code": "FULL_ADDER A a B b S s C_IN c_in C_OUT c_out \n# A: Augend bit, B: Addend bit, S: Sum Bit, \n# C_IN: Input carry, C_OUT: Output carry",
        "syntax": "FULL_ADDER {[Subcircuit-label-n] [label-n]}\nWhere, the Subcircuit labels are A, B, S, C_IN and C_OUT\nAll Subcircuit labels are mandatory\nOrder is arbitrary"
    },
    {
        "name": "Half Adder",
        "desc": "Performs binary addition of an Augend bit with an Added bit and generates Sum bit and Carry.",
        "truth_table": "",
        "code": "HALF_ADDER A a B b S s C c \n# A: Augend bit, B: Addend bit, S: Sum Bit, C: Input carry",
        "syntax": "FULL_ADDER {[Subcircuit-label-n] [label-n]}\nWhere, the Subcircuit labels are A, B, S, and C\nAll Subcircuit labels are mandatory\nOrder is arbitrary"
    },
    {
        "name": "4 Bit Johnshon Counter",
        "desc": "Generates the sequence of a 4-Bit Johnson Counter timed by the clock input.",
        "truth_table": "",
        "code": "4BIT_JOHNSON_COUNTER CNT clk RST rst Q0 q0 Q1 q1 Q2 q2 Q3 q3 \n# CNT: Negative edge-triggered count input (clock), \n# RST: Active-low asynchronous reset input, \n# Q(0-3): Sequence output",
        "syntax": "4BIT_JOHNSON_COUNTER {[Subcircuit-label-n] [label-n]}\n# Where, the Subcircuit labels are CNT, RST, Q(0-3)\n# All Subcircuit labels are mandatory\n# Order is arbitrary"
    },
    {
        "name": "4 Bit Ring Counter",
        "desc": "Generates the sequence of a 4-Bit Ring Counter timed by the clock input. Sequence is to be initated by activating the SET input for the MSB position (usually Ring count sequences consist of a single high bit, so the SET input is to be activated for a single clock edge).",
        "truth_table": "",
        "code": "4BIT_RING_COUNTER CNT clk RST rst SET set Q0 q0 Q1 q1 Q2 q2 Q3 q3 \n# CNT: Negative edge-triggered count input (clock), \n# RST: Active-low asynchronous reset input, \n# SET: Active-low asynchronous set input for the MSB position (Q3), \n# Q(0-3): Sequence output",
        "syntax": "4BIT_RING_COUNTER {[Subcircuit-label-n] [label-n]}\n# Where, the Subcircuit labels are CNT, SET, RST, Q(0-3)\n# All Subcircuit labels are mandatory\n# Order is arbitrary"
    },
    {
        "name": "4 Bit Ripple Counter",
        "desc": "4-BIT-RIPPLE COUNTER: Generates the 4 bit up counting sequence 0000 to 1111 (0 to 15 decimal) timed by the clock.",
        "truth_table": "",
        "code": "4BIT_RIPPLE_COUNTER CNT clk RST rst Q0 q0 Q1 q1 Q2 q2 Q3 q3 \n# CNT: Negative edge-triggered count input (clock), \n# RST: Active-low asynchronous reset input, \n# Q(0-3): Count output",
        "syntax": "4BIT_RIPPLE_COUNTER {[Subcircuit-label-n] [label-n]}\n# Where, the Subcircuit labels are CNT, RST, Q(0-3)\n# All Subcircuit labels are mandatory\n$ Order is arbitrary"
    },
    {
        "name": "BCD Ripple Counter",
        "desc": "Performs BCD (Binary Coded Decimal) counting (from 0 to 9), timed by the count(clock) input. Particularly used in displays, where more sections of the counter are cascaded to represent the tenth, hundredth positions and so on.",
        "truth_table": "",
        "code": "BCD_RIPPLE_COUNTER T clk T t Q0 q0 Q1 q1 Q2 q2 Q3 q3 \n# T: Count enable, \n# RST: Active-low asynchronous reset input, \n# Q(0-3): Count output",
        "syntax": "# Has two variants: \n BCD_RIPPLE_COUNTER {[Subcircuit-label-n] [label-n]}\n BCD_RIPPLE_COUNTER_ALT {[Subcircuit-label-n] [label-n]}\n# The second variant is a straightforward \n# implementation with a 4-Bit Ripple Counter with \n# a cascade extension and the first \n# variant is a more complex implementation\n# Where, the Subcircuit labels are T, RST, Q(0-3)\n# All Subcircuit labels are mandatory\n# Order is arbitrary"
    },
    {
        "name": "D Flip-Flop Negative edge triggered",
        "desc": "",
        "truth_table": "",
        "code": "",
        "syntax": ""
    },
    {
        "name": "D Flip-Flop Positive edge triggered",
        "desc": "",
        "truth_table": "",
        "code": "",
        "syntax": ""
    },
    {
        "name": "Gated D Latch",
        "desc": "Latches a single bit Q according to the inputs S and R. EN is the gate input (Active LOW level triggered).",
        "truth_table": "",
        "code": "D_LATCH_EN D d EN En Q q Q` q`",
        "syntax": "D_LATCH_EN {[Subcircuit-label-n] [label-n]}\n# Where, the Subcircuit labels are D, EN, Q, Q`\n# All Subcircuit labels are mandatory except the outputs\n# Order is arbitrary"
    },
    {
        "name": "JK Flip-Flop Negative edge triggered",
        "desc": "",
        "truth_table": "",
        "code": "",
        "syntax": ""
    },
    {
        "name": "JK Flip-Flop Negative edge triggered with Set and Reset",
        "desc": "",
        "truth_table": "",
        "code": "",
        "syntax": ""
    },
    {
        "name": "JK Flip-Flop Positive edge triggered",
        "desc": "",
        "truth_table": "",
        "code": "",
        "syntax": ""
    },
    {
        "name": "JK Flip-Flop Positive edge triggered with Set and Reset",
        "desc": "",
        "truth_table": "",
        "code": "",
        "syntax": ""
    },
    {
        "name": "Gated JK-Latch",
        "desc": "",
        "truth_table": "",
        "code": "",
        "syntax": ""
    },
    {
        "name": "S'R'-Latch",
        "desc": "Latches a single bit Q according to the input levels (active LOW).",
        "truth_table": "",
        "code": "S'R'_LATCH S s R r Q q Q` q`\n# Another example\nS'R'_LATCH S s R r Q q",
        "syntax": "S'R'_LATCH {[Subcircuit-label-n] [label-n]}\n# Where, the Subcircuit labels are S', R', Q, Q`\n# All Subcircuit labels are mandatory except the outputs\n# Order is arbitrary"
    },
    {
        "name": "SR-Latch",
        "desc": "Latches a single bit Q according to the input levels (active HIGH).",
        "truth_table": "",
        "code": "SR_LATCH S s R r Q q Q` q`\n# Another example\nSR_LATCH S s R r Q q",
        "syntax": "SR_LATCH {[Subcircuit-label-n] [label-n]}\n# Where, the Subcircuit labels are S, R, Q, Q`\n# All Subcircuit labels are mandatory except the outputs\n# Order is arbitrary"
    },
    {
        "name": "Gated SR-Latch",
        "desc": "Latches a single bit Q according to the inputs S and R. EN is the gate input (Active LOW level triggered).",
        "truth_table": "",
        "code": "SR_LATCH_EN S s R r EN En Q q Q` q`\n# Another example\nSR_LATCH S s R r EN En Q q",
        "syntax": "SR_LATCH_EN {[Subcircuit-label-n] [label-n]}\n# Where, the Subcircuit labels are S, R, EN, Q, Q`\n# All Subcircuit labels are mandatory except the outputs\n# Order is arbitrary"
    },
    {
        "name": "T Flip-Flop Negative edge triggered",
        "desc": "",
        "truth_table": "",
        "code": "",
        "syntax": ""
    },
    {
        "name": "T Flip-Flop Positive edge triggered",
        "desc": "",
        "truth_table": "",
        "code": "",
        "syntax": ""
    },
    {
        "name": "AND Gate",
        "desc": "The output of this gate is the logical AND operation of all input signals. In the first example given, A and B are the input signal pins and C is the output pin. By default, the last pin specified in the code is taken as the output pin of the Gate. Therefore, multiple inputs (2 or above) can be given to the AND gate.",
        "truth_table": "",
        "code" :"AND A B C #Two Inputs (A,B) and Output C\n\nAND A B C d #Three Inputs (A,B,C) and Output d", 
        "syntax" : "AND [input labels seperated by space] [output label]"
    },
    {
        "name": "NAND Gate",
        "desc": "The output of this gate is the logical NAND operation of all input signals. In the first example given, A and B are the input signal pins and C is the output pin. By default, the last pin specified in the code is taken as the output pin of the Gate. Therefore, multiple inputs (2 or above) can be given to the NAND gate.",
        "truth_table": "",
        "code": "NAND A B C #Two Inputs (A,B) and Output C\n\nNAND A B C d #Three Inputs (A,B,C) and Output d",
        "syntax": "NAND [input labels seperated by space] [output label]"
    },
    {
        "name": "NOR Gate",
        "desc": "The output of this gate is the logical NOR operation of all input signals. In the first example given, A and B are the input signal pins and C is the output pin. By default, the last pin specified in the code is taken as the output pin of the Gate. Therefore, multiple inputs (2 or above) can be given to the NOR gate.",
        "truth_table": "",
        "code": "NOR A B C #Two Inputs (A,B) and Output C\n\nNOR A B C d #Three Inputs (A,B,C) and Output d",
        "syntax": "NOR [input labels seperated by space] [output label]"
    },
    {
        "name": "NOT Gate",
        "desc": "NOT gate can be used to invert the digital logic of a given input signal (Logic high becomes Logic Low and vice-versa). Therefore, NOT Gate only has one input (A pin in example) and one output pin (B pin in example).",
        "truth_table": "",
        "code": "NOT A B",
        "syntax": "NOT [input label] [output label]"
    },
    {
        "name": "OR Gate",
        "desc": "The output of this gate is the logical OR operation of all input signals. In the first example given, A and B are the input signal pins and C is the output pin. By default, the last pin specified in the code is taken as the output pin of the Gate. Therefore, multiple inputs (2 or above) can be given to the OR gate.",
        "truth_table": "",
        "code": "OR A B C #Two Inputs (A,B) and Output C\n\nOR A B C d #Three Inputs (A,B,C) and Output d",
        "syntax": "OR [input labels seperated by space] [output label]"
    },
    {
        "name": "XOR Gate",
        "desc": "The output of this gate is the logical XOR operation of all input signals. In the first example given, A and B are the input signal pins and C is the output pin. By default, the last pin specified in the code is taken as the output pin of the Gate. Therefore, multiple inputs (2 or above) can be given to the XOR gate.",
        "truth_table": "",
        "code": "XOR A B C #Two Inputs (A,B) and Output C\n\nXOR A B C d #Three Inputs (A,B,C) and Output d",
        "syntax": "XOR [input labels seperated by space] [output label]"
    }
]